// The database type (mongo, couch, cassandra, squeryl, m2, postgres)
database = mongo

table Address {
    street: Text(200) indexed,notNull
    city: Text(200)
    state: State
    zip: ZipCode
}

table Owner {
    firstName: Text(200)
    lastName: Text(200)
    address: Address
    email: Email notNull
    phone: Phone
    projects: List[Project]
}

table Project {
    name: Text(200)
    description: Text(200)
    owner: Owner
}

/*
    The above would generate several things including:
    1) The mongo record classes and objects
    2) The initial stub in Boot
    3) The basic test classes

    In addition I think that the tool could potentially do the following:
    - create test records if it were smart about the names of things, much like the redgate tool that Darin showed me.
    - create regex versions of things.  For instance, Phone would be a regex-ified version of Text.

    The parser rules for the above are not very hard.  They basically come down to the following:

    script => databaseStatement? table*
    table => "table" identifier "{" tableBody
    tableBody => column*
    column => identifier ":" columnType option*
    option => notNull | indexed
    ... definitions for options ...
    columnType => textColumn | referenceColumn | stateColumn | phoneColumn | emailColumn |
                  textAreaColumn | intColumn | decimalColumn
    ... definitions for column types ...
*/