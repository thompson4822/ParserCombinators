/*
    Mueller Script vers 1.0
    -----------------------
    The purpose of this file is to demonstrate what Mueller Script (hereafter called MSL) is, why it was created, and
    how you can use it.

    Description
    -----------
    Ever looked at the code written from iteration to iteration and thought 'gee, this looks suspiciously the same as
    what I did before'?  If you have you've probably divined that there are particular patterns that we follow in our
    development of the Mueller project on practically all levels.

    Now this is both good and bad.  Obviously, the more closely a project hews to patterns of construction, the easier
    it becomes to read (wasn't this the central premise of the GOF book?).  Unfortunately, there is also a dark side to
    these patterns in that they entail replicating a certain amount of boilerplate every time they are used.

    MSL is designed to change all of that.  While it can't write business logic, it can alleviate some of the
    redundancy that has gone into building code in both the .Net and Flex areas.

    What is MSL?
    ------------
    MSL is a script language that describes in very simple terms the types of artifacts (files) that are to be
    generated.  It looks an awful lot like C#, which should make it easy to read.

    An MSL script must be accompanied by a properties file called msl.properties that contains information pertinent
    to the developers set up.  This was done in anticipation of having the script possibly be version controlled
    apart from the configuration for any one machine.
*/
/*
    The Properties File
    -------------------
    The best way to demonstrate the properties file is to show the content of my own:

        netSrc=c:/Projects/mueller-mihan
        flexCommonSrc=c:/Projects/mueller-mihan/MiHan_FlexCommon/src
        flexConsumerSrc=c:/Projects/mueller-mihan/MiHan_ConsumerPortal/src
        flexUtilitySrc=c:/Projects/mueller-mihan/MiHan_UtilityPortal/src

        netServiceConsumer=Mueller.Han.Service
        netServiceAdmin=Mueller.Han.Service.Admin
        netServiceCommon=Mueller.Han.Service.Admin.Common
        netFactory=Mueller.Han.Business
        netFactoryTest=Mueller.Han.Business.Test

        flexBasePackage=com.mueller.mihan

    All of the keys shown here must have definition.  Obviously the first 4 are the most likely to vary from one user
    to another.  In future releases I might generalize the Flex source keys further to just define a common workspace.

    Lets See Some Script Already
    ----------------------------
    In the following, we'll go ahead and start examining script code, explaining what it does as we go along.
*/

// This is a single line comment.

/*
    This is a multi line comment.

    Comment limitations include:
    - Both single and multi line comments can only currently be used at the top level (not inside of service/factory
      declarations, which we'll look at next)
    - Multi-line comments don't nest, so don't try this!
*/

// Let's declare a factory
CustomerDeviceFactory { }

/*
    There are several things about this code to note:
    1) Naming is important.  A factory definition must end with the word 'Factory'  This implies added consistency.
    2) After the name there can be a factory body.  In this case the body is not defined.  Curly braces are required
       in both cases.

    Not surprisingly, this code doesn't really help too much.  Let's add some definition to it:
*/

CustomerDeviceFactory {
    IList<Device> DevicesFor(string customerId, DeviceType deviceType)
    string DeviceName(long deviceId, long customerId)
    long DeviceId(string deviceName, long customerId)
}

/*
    Again, there are some things to note:
    1) Definitions look just like C# method signatures, except there is no ';'.  Convince me to add it and I will :)
    2) Multiple declarations are cumulative, meaning that we could declare CustomerDeviceFactory ten times with
       ten slightly different bodies, and the result would be a single CustomerDeviceFactory that amalgamated all the
       body definitions

    Now the CustomerDeviceFactory has enough definition to actually be interesting.  It will generate for us the
    following files with the contents as shown:

       [ICustomerDeviceFactory.cs]

*/

/*
CustomerDeviceService[Utility] {
    IList<Device> DevicesFor(string customerId, DeviceType deviceType)
    string DeviceName(long deviceId, long customerId)
    long DeviceId(string deviceName, long customerId)
}

MyCrazyFactory {
    inject IFirstDao firstDao
    inject IAteSomethingBad ateSomethingBad
    bool IsCrazy()
    IList<CrazyType> CrazyInWhatWays(long id)
}

flex[Utility]=customerDevice
*/
